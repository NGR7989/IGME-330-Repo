/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/audio.js":
/*!**********************!*\
  !*** ./src/audio.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyserNode: () => (/* binding */ analyserNode),\n/* harmony export */   audioCtx: () => (/* binding */ audioCtx),\n/* harmony export */   loadSoundFile: () => (/* binding */ loadSoundFile),\n/* harmony export */   pauseCurrentSound: () => (/* binding */ pauseCurrentSound),\n/* harmony export */   playCurrentSound: () => (/* binding */ playCurrentSound),\n/* harmony export */   setVolume: () => (/* binding */ setVolume),\n/* harmony export */   setupWebaudio: () => (/* binding */ setupWebaudio)\n/* harmony export */ });\n// 1 - our WebAudio context, **we will export and make this public at the bottom omodulef the file**\nvar audioCtx;\n\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\nvar element, sourceNode, analyserNode, gainNode;\n\n// 3 - here we are faking an enumeration\nvar DEFAULTS = Object.freeze({\n  gain: 5,\n  numSamples: 256\n});\n\n// 4 - create a new array of 8-bit integers (0-255)\n// this is a typed array to hold the audio frequency data\nvar audioData = new Uint8Array(DEFAULTS.numSamples / 2);\nvar biquadFilterHigh;\nvar biquadFilterLow;\nvar highshelf = false;\nvar lowshelf = false;\nvar distortionFilter;\nvar distortion = false;\nvar distortionAmount = 20;\nvar volumeSlider;\nvar volumeLabel;\nvar toggleHighshelf = function toggleHighshelf() {\n  if (highshelf) {\n    biquadFilterHigh.frequency.setValueAtTime(1000, audioCtx.currentTime); // we created the `biquadFilter` (i.e. \"treble\") node last time\n    biquadFilterHigh.gain.setValueAtTime(25, audioCtx.currentTime);\n  } else {\n    biquadFilterHigh.gain.setValueAtTime(0, audioCtx.currentTime);\n  }\n};\nvar toggleLowshelf = function toggleLowshelf() {\n  if (lowshelf) {\n    biquadFilterLow.frequency.setValueAtTime(1000, audioCtx.currentTime);\n    biquadFilterLow.gain.setValueAtTime(15, audioCtx.currentTime);\n  } else {\n    biquadFilterLow.gain.setValueAtTime(0, audioCtx.currentTime);\n  }\n};\nvar toggleDistortion = function toggleDistortion() {\n  if (distortion) {\n    distortionFilter.curve = null; // being paranoid and trying to trigger garbage collection\n    distortionFilter.curve = makeDistortionCurve(distortionAmount);\n  } else {\n    distortionFilter.curve = null;\n  }\n};\n\n// from: https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\nvar makeDistortionCurve = function makeDistortionCurve() {\n  var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n  var n_samples = 256,\n    curve = new Float32Array(n_samples);\n  for (var i = 0; i < n_samples; ++i) {\n    var x = i * 2 / n_samples - 1;\n    curve[i] = (Math.PI + amount) * x / (Math.PI + amount * Math.abs(x));\n  }\n  return curve;\n};\nvar setupUI = function setupUI() {\n  // I. set the initial state of the high shelf checkbox\n  document.querySelector('#cb-highshelf').checked = highshelf; // `highshelf` is a boolean we will declare in a second\n\n  // II. change the value of `highshelf` every time the high shelf checkbox changes state\n  document.querySelector('#cb-highshelf').onchange = function (e) {\n    highshelf = e.target.checked;\n    toggleHighshelf(); // turn on or turn off the filter, depending on the value of `highshelf`!\n  };\n\n  document.querySelector('#cb-lowshelf').onchange = function (e) {\n    lowshelf = e.target.checked;\n    toggleLowshelf(); // turn on or turn off the filter, depending on the value of `highshelf`!\n  };\n\n  // III. \n  toggleHighshelf(); // when the app starts up, turn on or turn off the filter, depending on the value of `highshelf`!\n\n  document.querySelector(\"#cb-distortion\").onchange = function (e) {\n    distortion = e.target.checked;\n    toggleDistortion();\n  };\n  document.querySelector('#slider-distortion').value = distortionAmount;\n  document.querySelector('#slider-distortion').onchange = function (e) {\n    distortionAmount = Number(e.target.value);\n    toggleDistortion();\n  };\n  volumeSlider = document.querySelector(\"#slider-volume\");\n  volumeLabel = document.querySelector(\"#label-volume\");\n  volumeSlider.oninput = function (e) {\n    gainNode.setValueAtTime = (e.target.value, audioCtx.currentTime);\n    volumeLabel.innerHTML = Math.round(e.target.value / 2 * 100);\n  };\n  volumeSlider.dispatchEvent(new Event(\"input\"));\n};\n\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\nvar setupWebaudio = function setupWebaudio(filePath) {\n  // 1 - The || is because WebAudio has not been standardized across browsers yet\n  var AudioContext = window.AudioContext || window.webkitAudioContext;\n  audioCtx = new AudioContext();\n\n  // 2 - this creates an <audio> element\n  element = new Audio();\n\n  // 3 - have it point at a sound file\n  loadSoundFile(filePath);\n\n  // 4 - create an a source node that points at the <audio> element\n  sourceNode = audioCtx.createMediaElementSource(element);\n\n  // 5 - create an analyser node\n  // note the UK spelling of \"Analyser\"\n  analyserNode = audioCtx.createAnalyser();\n  biquadFilterHigh = audioCtx.createBiquadFilter();\n  biquadFilterHigh.type = \"highshelf\";\n  biquadFilterLow = audioCtx.createBiquadFilter();\n  biquadFilterLow.type = \"lowshelf\";\n  distortionFilter = audioCtx.createWaveShaper();\n\n  /*\r\n  // 6\r\n  We will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\n  across the sound spectrum.\r\n  \r\n    If DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\n  the third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\n  the amplitude of that frequency.\r\n  */\n  sourceNode.connect(biquadFilterHigh);\n  biquadFilterHigh.connect(biquadFilterLow);\n  biquadFilterLow.connect(distortionFilter);\n  distortionFilter.connect(analyserNode);\n\n  // fft stands for Fast Fourier Transform\n  analyserNode.fftSize = DEFAULTS.numSamples;\n\n  // 7 - create a gain (volume) node\n  gainNode = audioCtx.createGain();\n  gainNode.gain.value = DEFAULTS.gain;\n\n  // 8 - connect the nodes - we now have an audio graph\n  sourceNode.connect(analyserNode);\n  analyserNode.connect(gainNode);\n  gainNode.connect(audioCtx.destination);\n  setupUI();\n};\n// make sure that it's a Number rather than a String\n\nvar loadSoundFile = function loadSoundFile(filePath) {\n  element.src = filePath;\n};\nvar playCurrentSound = function playCurrentSound() {\n  element.play();\n};\nvar pauseCurrentSound = function pauseCurrentSound() {\n  element.pause();\n};\nvar setVolume = function setVolume(value) {\n  value = Number(value);\n  gainNode.gain.value = value;\n};\n\n\n//# sourceURL=webpack://risser-n-hw2/./src/audio.js?");

/***/ }),

/***/ "./src/canvas.js":
/*!***********************!*\
  !*** ./src/canvas.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   draw: () => (/* binding */ draw),\n/* harmony export */   setupCanvas: () => (/* binding */ setupCanvas)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/*\r\n\tThe purpose of this file is to take in the analyser node and a <canvas> element: \r\n\t  - the module will create a drawing context that points at the <canvas> \r\n\t  - it will store the reference to the analyser node\r\n\t  - in draw(), it will loop through the data in the analyser node\r\n\t  - and then draw something representative on the canvas\r\n\t  - maybe a better name for this file/module would be *visualizer.js* ?\r\n*/\n\n\nvar ctx, canvasWidth, canvasHeight, gradient, analyserNode, audioData;\nvar botWidth = 120;\nvar avgHeight = 0;\nvar getRandomColor = function getRandomColor() {\n  function getByte() {\n    return 55 + Math.round(Math.random() * 200);\n  }\n  return \"rgba(\" + getByte() + \",\" + getByte() + \",\" + getByte() + \",.8)\";\n};\nvar setupCanvas = function setupCanvas(canvasElement, analyserNodeRef) {\n  // create drawing context\n  ctx = canvasElement.getContext(\"2d\");\n  canvasWidth = canvasElement.width;\n  canvasHeight = canvasElement.height;\n  // create a gradient that runs top to bottom\n  gradient = _utils_js__WEBPACK_IMPORTED_MODULE_0__.getLinearGradient(ctx, 0, 0, 0, canvasHeight, [{\n    percent: 0,\n    color: \"#DAFFFB\"\n  }, {\n    percent: .25,\n    color: \"#176B87\"\n  }, {\n    percent: .5,\n    color: \"#04364A\"\n  }, {\n    percent: .75,\n    color: \"#176B87\"\n  }, {\n    percent: 1,\n    color: \"#DAFFFB\"\n  }]);\n  // keep a reference to the analyser node\n  analyserNode = analyserNodeRef;\n  // this is the array where the analyser data will be stored\n  audioData = new Uint8Array(analyserNode.fftSize / 2);\n};\nvar drawRect = function drawRect(ctx, x, y, width, height) {\n  var fillStyle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"black\";\n  var lineWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var strokeStyle = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : \"black\";\n  ctx.save();\n  ctx.beginPath();\n  ctx.lineWidth = lineWidth;\n  ctx.strokeStyle = strokeStyle;\n  ctx.fillStyle = fillStyle;\n  ctx.rect(x, y, width, height);\n  ctx.closePath();\n  ctx.fill();\n  ctx.stroke();\n  ctx.restore();\n};\nvar draw = function draw() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Draw head\n  drawRect(ctx, 375, 170, 50, 25, \"#363062\", 0, \"#363062\"); // Neck\n  drawRect(ctx, 360, 150, 80, 20, \"#F99417\", 0, \"#F99417\"); // Bottom Jaw\n  drawRect(ctx, 350, 100 - avgHeight * 1.5, 100, 50, \"#4D4C7D\", 4, \"#4D4C7D\"); // Top Head\n\n  // Arms\n  drawRect(ctx, 330, 215, 10, 20, \"#363062\", 0, \"#363062\"); // Left Connect \n  drawRect(ctx, 324, 200, 4, 120, \"#F99417\", 0, \"#F99417\"); // Left Arm\n  drawRect(ctx, 460, 215, 10, 20, \"#363062\", 0, \"#363062\"); // Right Connect \n  drawRect(ctx, 470, 200, 4, 120, \"#F99417\", 0, \"#F99417\"); // Right Arm\n\n  // Legs \n  drawRect(ctx, 360, 335, 10, 50, \"#363062\", 4, \"#363062\"); // Left Leg  \n  drawRect(ctx, 350, 385, 20, 10, \"#4D4C7D\", 4, \"#4D4C7D\"); // Left Foot  \n  drawRect(ctx, 430, 335, 10, 50, \"#363062\", 4, \"#363062\"); // Right Leg  \n  drawRect(ctx, 430, 385, 20, 10, \"#4D4C7D\", 4, \"#4D4C7D\"); // Right FOot   \n\n  // Main Body\n  drawRect(ctx, 340, 195, botWidth, 140, \"#4D4C7D\", 0, \"#4D4C7D\"); // Body Frame\n  drawRect(ctx, 350, 210, 100, 20, \"#F5F5F5\", 0, \"black\"); // Song Display \n  drawRect(ctx, 350, 260, 100, 50, \"#F5F5F5\", 0, \"#black\"); // Wire Display \n\n  // 1 - populate the audioData array with the frequency data from the analyserNode\n  // notice these arrays are passed \"by reference\" \n  analyserNode.getByteFrequencyData(audioData);\n  // OR\n  //analyserNode.getByteTimeDomainData(audioData); // waveform data\n\n  // 2 - draw background\n  ctx.save();\n  ctx.fillStyle = \"black\";\n  ctx.globalAlpha = 0.1;\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n  ctx.restore();\n  // 3 - draw gradient\n  if (params.showGradient) {\n    ctx.save();\n    ctx.fillStyle = gradient;\n    ctx.globalAlpha = 0.3;\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.restore();\n  }\n  // 4 - draw bars\n  if (params.talk) {\n    var barSpacing = 0;\n    var margin = 360;\n    //let screenWidthForBars = botWidth  - (audioData.length * barSpacing) - margin * 2;\n    var barWidth = 80 / audioData.length;\n    var barHeight = 30;\n    var topSpacing = 150;\n    var heightMul = 0.2;\n    var sum = 0;\n    ctx.save();\n    ctx.fillStyle = 'rgba(255,255,255,0.50)';\n    ctx.strokeStyle = 'rgba(0,0,0,0.50)';\n\n    // Loop through data to draw  \n    for (var i = 0; i < audioData.length; i++) {\n      var difference = audioData[i] * heightMul;\n      if (i > 20) {\n        sum += difference;\n      }\n      //ctx.fillRect(margin + i * (barWidth + barSpacing), topSpacing - difference, barWidth, barHeight); // 256 - audiodat.. for y\n      //ctx.strokeRect(margin + i * (barWidth + barSpacing), topSpacing - difference, barWidth, barHeight);\n    }\n\n    avgHeight = sum / audioData.length;\n    ctx.restore();\n  } else {\n    avgHeight = 0;\n  }\n\n  // 5 - draw circles\n  if (params.showLine) {\n    ctx.save();\n    ctx.strokeStyle = \"#black\";\n    ctx.lineWidth = 3;\n    var startX = 355;\n    var _width = 90;\n    var x = 0;\n    var middleY = 295;\n    var y = middleY;\n    ctx.beginPath();\n    ctx.moveTo(startX, y);\n    var _iterator = _createForOfIteratorHelper(audioData),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var b = _step.value;\n        ctx.lineTo(startX + x, y - Math.min(b * 0.1, 30));\n        x += _width / audioData.length;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    ctx.stroke();\n    ctx.closePath();\n    ctx.restore();\n\n    // let maxRadius = canvasHeight / 4;\n    // ctx.save();\n    // ctx.globalAlpha = 0.5;\n\n    // for(let i = 0; i < audioData.length; i++)\n    // {\n    //     let percent = audioData[i] / 255;\n\n    //     // Blueish circles \n    //     let circleRadius = percent * maxRadius;\n    //     ctx.beginPath();\n    //     ctx.fillStyle = utils.makeColor(255, 111, 111, 0.34 - percent / 3.0);\n    //     ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius, 0, 2 * Math.PI, false);\n    //     ctx.fill();\n    //     ctx.closePath();\n\n    //     // Yellowish circles \n    //     ctx.save();\n    //     ctx.beginPath();\n    //     ctx.fillStyle = utils.makeColor(200, 200, 0, 0.5 - percent / 5.0);\n    //     ctx.arc(canvasWidth / 2, canvasHeight / 2, circleRadius * 0.50, 0, 2 * Math.PI, false);\n    //     ctx.fill();\n    //     ctx.closePath();\n    //     ctx.restore();\n    // }\n    // ctx.restore();\n  }\n\n  // 6 - bitmap manipulation\n  // TODO: right now. we are looping though every pixel of the canvas (320,000 of them!), \n  // regardless of whether or not we are applying a pixel effect\n  // At some point, refactor this code so that we are looping though the image data only if\n  // it is necessary\n\n  // A) grab all of the pixels on the canvas and put them in the `data` array\n  // `imageData.data` is a `Uint8ClampedArray()` typed array that has 1.28 million elements!\n  // the variable `data` below is a reference to that array \n  var imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n  var data = imageData.data;\n  var length = data.length;\n  var width = imageData.width;\n\n  // B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\n  for (var _i = 0; _i < length; _i += 4) {\n    // C) randomly change every 20th pixel to red\n\n    if (params.showNoise && Math.random() < 0.05) {\n      // data[i] is the red channel\n      // data[i+1] is the green channel\n      // data[i+2] is the blue channel\n      // data[i+3] is the alpha channel\n\n      data[_i] = data[_i + 1] = data[_i + 2] = 255; // zero out the red and green and blue channels\n      //data[i] = 255;  // make the red channel 100% red\n    }\n\n    if (params.showInvert) {\n      var red = data[_i],\n        green = data[_i + 1],\n        blue = data[_i + 2];\n      data[_i] = 255 - red;\n      data[_i + 1] = 255 - green;\n      data[_i + 2] = 255 - blue;\n      // data[i + 3] is the alpha \n    }\n  }\n\n  if (params.showEmboss) {\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      if (_i2 % 4 == 3) continue; // skill alpha \n      data[_i2] = 127 + 2 * data[_i2] - data[_i2 + 4] - data[_i2 + width * 4];\n    }\n  }\n\n  // D) copy image data back to canvas\n  ctx.putImageData(imageData, 0, 0);\n};\n\n\n//# sourceURL=webpack://risser-n-hw2/./src/canvas.js?");

/***/ }),

/***/ "./src/loader.js":
/*!***********************!*\
  !*** ./src/loader.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.js */ \"./src/main.js\");\n\nwindow.onload = function () {\n  console.log(\"window.onload called\");\n  // 1 - do preload here - load fonts, images, additional sounds, etc...\n\n  // 2 - start up app\n  _main_js__WEBPACK_IMPORTED_MODULE_0__.init();\n};\n\n//# sourceURL=webpack://risser-n-hw2/./src/loader.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   init: () => (/* binding */ init)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _audio_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio.js */ \"./src/audio.js\");\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas.js */ \"./src/canvas.js\");\n/*\r\n\tmain.js is primarily responsible for hooking up the UI to the rest of the application \r\n\tand setting up the main event loop\r\n*/\n\n// We will write the functions in this file in the traditional ES5 way\n// In this instance, we feel the code is more readable if written this way\n// If you want to re-write these as ES6 arrow functions, to be consistent with the other files, go ahead!\n\n\n\n\nvar drawParams = {\n  showGradient: false,\n  talk: true,\n  showLine: true,\n  showNoise: false,\n  showInvert: false,\n  showEmboss: false\n};\n\n// 1 - here we are faking an enumeration\nvar DEFAULTS = Object.freeze({\n  sound1: \"media/ULTRAKILL.mp3\"\n});\nvar loop = function loop() {\n  /* NOTE: This is temporary testing code that we will delete in Part II */\n  //requestAnimationFrame(loop);\n\n  setTimeout(loop, 1000 / 60);\n  _canvas_js__WEBPACK_IMPORTED_MODULE_2__.draw(drawParams);\n\n  // Old debug information below \n\n  // 1) create a byte array (values of 0-255) to hold the audio data\n  // normally, we do this once when the program starts up, NOT every frame\n  // let audioData = new Uint8Array(audio.analyserNode.fftSize/2);\n\n  // 2) populate the array of audio data *by reference* (i.e. by its address)\n  //audio.analyserNode.getByteFrequencyData(audioData);\n\n  // 3) log out the array and the average loudness (amplitude) of all of the frequency bins\n  // console.log(audioData);\n\n  // console.log(\"-----Audio Stats-----\");\n  // let totalLoudness =  audioData.reduce((total,num) => total + num);\n  // let averageLoudness =  totalLoudness/(audio.analyserNode.fftSize/2);\n  // let minLoudness =  Math.min(...audioData); // ooh - the ES6 spread operator is handy!\n  // let maxLoudness =  Math.max(...audioData); // ditto!\n  // // Now look at loudness in a specific bin\n  // // 22050 kHz divided by 128 bins = 172.23 kHz per bin\n  // // the 12th element in array represents loudness at 2.067 kHz\n  // let loudnessAt2K = audioData[11]; \n  // console.log(`averageLoudness = ${averageLoudness}`);\n  // console.log(`minLoudness = ${minLoudness}`);\n  // console.log(`maxLoudness = ${maxLoudness}`);\n  // console.log(`loudnessAt2K = ${loudnessAt2K}`);\n  // console.log(\"---------------------\");\n};\n\nvar loadJson = function loadJson() {\n  var url = \"data/av-data.json\";\n  var xhr = new XMLHttpRequest();\n  xhr.onload = function (e) {\n    console.log(\"In onload - HTTP Status Code = \".concat(e.target.status));\n    var text = e.target.responseText;\n    var json = JSON.parse(text);\n    var title = json[\"title\"];\n    var songTitle = json[\"songTitles\"];\n    var instruct = json[\"funky\"];\n    document.querySelector(\"#title\").innerHTML = title;\n    document.querySelector(\"#desc\").innerHTML = instruct;\n  };\n  xhr.onerror = function (e) {\n    return console.log(\"In onerror - HTTP Status Code = \".concat(e.target.status));\n  };\n  xhr.open(\"GET\", url);\n  xhr.send();\n};\nvar setupUI = function setupUI(canvasElement) {\n  // A - hookup fullscreen button\n  var fsButton = document.querySelector(\"#fs-button\");\n\n  // add .onclick event to button\n  fsButton.onclick = function (e) {\n    console.log(\"goFullscreen() called\");\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.goFullscreen(canvasElement);\n  };\n  playButton.onclick = function (e) {\n    console.log(\"audioCtx.state before = \".concat(_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state));\n    if (_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state == \"suspended\") {\n      _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.resume();\n    }\n    if (_audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.state == \"running\") {\n      _audio_js__WEBPACK_IMPORTED_MODULE_1__.audioCtx.suspend();\n      playButton.content = \"no\";\n    }\n    if (e.target.dataset.playing == \"no\") {\n      _audio_js__WEBPACK_IMPORTED_MODULE_1__.playCurrentSound();\n      e.target.dataset.playButton = \"yes\";\n    } else {\n      _audio_js__WEBPACK_IMPORTED_MODULE_1__.pauseCurrentSound();\n      e.target.dataset.playButton = \"no\";\n    }\n  };\n\n  // Hookup track\n  var trackSelect = document.querySelector(\"#track-select\");\n  trackSelect.onchange = function (e) {\n    _audio_js__WEBPACK_IMPORTED_MODULE_1__.loadSoundFile(e.target.value);\n    if (playButton.dataset.playing == \"yes\") {\n      playButton.dispatchEvent(new MouseEvent(\"click\"));\n    }\n  };\n\n  // Set up checkboxes \n  var btnGradient = document.querySelector(\"#cb-gradient\");\n  btnGradient.checked = true;\n  btnGradient.onclick = function () {\n    drawParams.showGradient = btnGradient.checked;\n  };\n  var btnBars = document.querySelector(\"#cb-talk\");\n  btnBars.checked = true;\n  btnBars.onclick = function () {\n    drawParams.talk = btnBars.checked;\n  };\n  var btnLine = document.querySelector(\"#cb-line\");\n  btnLine.checked = true;\n  btnLine.onclick = function () {\n    drawParams.showLine = btnLine.checked;\n  };\n  var btnNoise = document.querySelector(\"#cb-noise\");\n  btnNoise.checked = false;\n  btnNoise.onclick = function () {\n    drawParams.showNoise = btnNoise.checked;\n  };\n  var btnInvert = document.querySelector(\"#cb-invert\");\n  btnInvert.checked = false;\n  btnInvert.onclick = function () {\n    drawParams.showInvert = btnInvert.checked;\n  };\n  var btnEmboss = document.querySelector(\"#cb-emboss\");\n  btnEmboss.checked = false;\n  btnEmboss.onclick = function () {\n    drawParams.showEmboss = btnEmboss.checked;\n  };\n  loadJson();\n}; // end setupUI\n\nvar init = function init() {\n  _audio_js__WEBPACK_IMPORTED_MODULE_1__.setupWebaudio(DEFAULTS.sound1);\n  console.log(\"init called\");\n  console.log(\"Testing utils.getRandomColor() import: \".concat(_utils_js__WEBPACK_IMPORTED_MODULE_0__.getRandomColor()));\n  var canvasElement = document.querySelector(\"canvas\"); // hookup <canvas> element\n  setupUI(canvasElement);\n  _canvas_js__WEBPACK_IMPORTED_MODULE_2__.setupCanvas(canvasElement, _audio_js__WEBPACK_IMPORTED_MODULE_1__.analyserNode);\n  loop();\n};\n\n\n//# sourceURL=webpack://risser-n-hw2/./src/main.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLinearGradient: () => (/* binding */ getLinearGradient),\n/* harmony export */   getRandomColor: () => (/* binding */ getRandomColor),\n/* harmony export */   goFullscreen: () => (/* binding */ goFullscreen),\n/* harmony export */   makeColor: () => (/* binding */ makeColor)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar makeColor = function makeColor(red, green, blue) {\n  var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  return \"rgba(\".concat(red, \",\").concat(green, \",\").concat(blue, \",\").concat(alpha, \")\");\n};\nvar getRandom = function getRandom(min, max) {\n  return Math.random() * (max - min) + min;\n};\nvar getRandomColor = function getRandomColor() {\n  var floor = 35; // so that colors are not too bright or too dark \n  var getByte = function getByte() {\n    return getRandom(floor, 255 - floor);\n  };\n  return \"rgba(\".concat(getByte(), \",\").concat(getByte(), \",\").concat(getByte(), \",1)\");\n};\nvar getLinearGradient = function getLinearGradient(ctx, startX, startY, endX, endY, colorStops) {\n  var lg = ctx.createLinearGradient(startX, startY, endX, endY);\n  var _iterator = _createForOfIteratorHelper(colorStops),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var stop = _step.value;\n      lg.addColorStop(stop.percent, stop.color);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return lg;\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\nvar goFullscreen = function goFullscreen(element) {\n  if (element.requestFullscreen) {\n    element.requestFullscreen();\n  } else if (element.mozRequestFullscreen) {\n    element.mozRequestFullscreen();\n  } else if (element.mozRequestFullScreen) {\n    // camel-cased 'S' was changed to 's' in spec\n    element.mozRequestFullScreen();\n  } else if (element.webkitRequestFullscreen) {\n    element.webkitRequestFullscreen();\n  }\n  // .. and do nothing if the method is not supported\n};\n\n\n\n//# sourceURL=webpack://risser-n-hw2/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/loader.js");
/******/ 	
/******/ })()
;